<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>AI Chat Frame</title>
    <style>
      :root {
        --radius: 10px;
        --border: 1px solid rgba(0,0,0,0.08);
        --bg: #ffffff;
        --panel: #fafafa;
        --muted: #666;
        --text: #1f1f1f;
        --accent: #3f51b5;
      }
      * { box-sizing: border-box; }
      html, body {
        height: 100%;
        margin: 0;
        background: transparent;
        color: var(--text);
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei", sans-serif;
        font-size: 14px;
      }
      .chat-root {
        position: relative;
        display: flex;
        flex-direction: column;
        height: 100%;
        padding: 6px;
        background: var(--bg);
        border-radius: var(--radius);
      }
      .messages {
        flex: 1;
        overflow: auto;
        padding: 8px;
        border: var(--border);
        border-radius: 8px;
        background: var(--panel);
      }
      .msg { margin: 6px 0; display: flex; gap: 8px; align-items: flex-start; }
      .msg.user { justify-content: flex-end; }
      .avatar { width: 28px; height: 28px; border-radius: 50%; flex-shrink: 0; background-size: cover; background-position: center; }
      .msg.assistant .avatar { background-image: var(--assistant-avatar); }
      .bubble {
        max-width: 85%;
        padding: 8px 10px;
        border-radius: 10px;
        background: #fff;
        border: var(--border);
        box-shadow: 0 1px 3px rgba(0,0,0,0.05);
        white-space: pre-wrap;
        word-break: break-word;
      }
      /* Compact mode: plain text only, centered, no bubble background */
      body.compact .messages { border: none; background: transparent; padding: 0; display: flex; align-items: center; justify-content: center; }
      body.compact .msg { margin: 0; width: 100%; display: flex; justify-content: center; }
      body.compact .bubble { background: transparent; border: none; box-shadow: none; padding: 0; max-width: 90%; color: var(--text); font-size: 15px; line-height: 1.7; text-align: center; }
      .fade-in { animation: fadeIn 150ms ease-out; }
      @keyframes fadeIn { from { opacity: 0 } to { opacity: 1 } }
      .footer {
        display: flex;
        align-items: flex-end;
        gap: 8px;
        margin-top: 8px;
      }
      .textarea-wrap { flex: 1; position: relative; }
      textarea {
        width: 100%;
        min-height: 20px; /* 一开始占一行 */
        height: 20px;
        max-height: 120px; /* will be overridden by param */
        resize: none;
        padding: 8px 10px;
        line-height: 20px;
        border-radius: 8px;
        border: var(--border);
        outline: none;
        background: #fff;
        color: var(--text);
        overflow: auto;
      }
      textarea:disabled { background: #f5f5f5; color: #999; }
      /* 右下角小圆形发送按钮（嵌入输入框内） */
      .send-fab {
        position: absolute; right: 8px; bottom: 8px;
        width: 30px; height: 30px; border-radius: 50%;
        display: inline-flex; align-items: center; justify-content: center;
        background: var(--accent); color: #fff; border: none; cursor: pointer;
        box-shadow: 0 2px 6px rgba(0,0,0,0.15);
      }
      .send-fab:disabled { opacity: 0.6; cursor: not-allowed; }
      .spinner { width: 16px; height: 16px; border: 2px solid rgba(255,255,255,0.6); border-top-color: #fff; border-radius: 50%; animation: spin 0.8s linear infinite; }
      @keyframes spin { to { transform: rotate(360deg); } }
      /* 左下角圆形菜单（包含 MCP 启用与设置） */
      .mcp-fab {
        position: absolute; left: 8px; top: 8px;
        width: 30px; height: 30px; border-radius: 50%;
        display: inline-flex; align-items: center; justify-content: center;
        background: #e9e9e9; color: #333; border: none; cursor: pointer;
        box-shadow: 0 2px 6px rgba(0,0,0,0.1);
        z-index: 5;
      }
      .mcp-fab.enabled { background: #00bcd4; color: #fff; }
      .mcp-menu {
        position: absolute; left: 8px; top: 48px;
        background: #fff; border: 1px solid rgba(0,0,0,0.08);
        border-radius: 10px; box-shadow: 0 6px 18px rgba(0,0,0,0.12);
        min-width: 160px; padding: 6px; display: none;
        z-index: 5;
      }
      .mcp-menu.open { display: block; }
      .menu-item { display: flex; align-items: center; justify-content: space-between; gap: 8px; padding: 8px 10px; border-radius: 8px; cursor: pointer; }
      .menu-item:hover { background: #f5f7fb; }
      .menu-item .label { font-size: 13px; color: #333; }
      /* 细线滚动条样式（在达到最大高度时才出现） */
      .messages::-webkit-scrollbar { width: 4px; }
      .messages::-webkit-scrollbar-track { background: transparent; }
      .messages::-webkit-scrollbar-thumb { background: rgba(0,0,0,0.25); border-radius: 2px; }
    </style>
  </head>
  <body>
    <div class="chat-root">
      <div id="messages" class="messages"></div>
      <div class="footer">
        <div class="textarea-wrap">
          <textarea id="input" placeholder="输入消息，Enter 发送，Shift+Enter 换行"></textarea>
          <button id="mcp" class="mcp-fab" aria-label="菜单">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
              <path d="M3 6h18v2H3V6zm0 5h18v2H3v-2zm0 5h18v2H3v-2z" fill="currentColor"/>
            </svg>
          </button>
          <div id="mcpMenu" class="mcp-menu">
            <div class="menu-item" id="mcpToggle">
              <span class="label">MCP 启用</span>
              <input id="mcpSwitch" type="checkbox"/>
            </div>
            <div class="menu-item" id="openSettings">
              <span class="label">设置</span>
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M12 8a4 4 0 100 8 4 4 0 000-8zm9.4 4a7.4 7.4 0 01-.1 1l2.1 1.6-2 3.5-2.5-1a7.7 7.7 0 01-1.7 1l-.4 2.7H9.2l-.4-2.7a7.7 7.7 0 01-1.7-1l-2.5 1-2-3.5 2.1-1.6a7.4 7.4 0 01-.1-1c0-.3 0-.7.1-1L.9 9.4 2.9 6l2.5 1c.5-.4 1.1-.8 1.7-1l.4-2.7h5.6l.4 2.7c.6.2 1.2.6 1.7 1l2.5-1 2 3.4-2.1 1.6c.1.3.1.7.1 1z" fill="#666"/></svg>
            </div>
          </div>
          <button id="send" class="send-fab" title="发送">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
              <path d="M2 21L23 12L2 3V10L17 12L2 14V21Z" fill="currentColor"/>
            </svg>
          </button>
        </div>
      </div>
    </div>

    <script>
      (function(){
        const params = new URLSearchParams(location.search);
        const apiBase = 'http://localhost:8080/api';
        const endpointNormal = apiBase + '/character/generateStream';
        const endpointMcp = apiBase + '/mcp/generateStream';
        const endpointHistory = apiBase + '/character/getHistoryMessage';
        const maxInputPx = parseInt(params.get('maxInputPx') || '120', 10);
        const mode = params.get('mode') || 'compact';
        const externalMcp = params.get('externalMcp') === '1';
        if (mode === 'compact') document.body.classList.add('compact');

        const elMessages = document.getElementById('messages');
        const elInput = document.getElementById('input');
        const elSend = document.getElementById('send');
        const elMcp = document.getElementById('mcp');
        const elMcpMenu = document.getElementById('mcpMenu');
        const elMcpSwitch = document.getElementById('mcpSwitch');

        let disabled = false;
        let mcpEnabled = false;
        // Full-mode history cache and paging state
        let historyCache = [];
        let historyLoadedStart = 0; // inclusive index into historyCache
        let historyLoadedEnd = 0;   // exclusive index
        const historyPageSize = 10;

        function extractTextFromObj(obj) {
          if (!obj || typeof obj !== 'object') return '';
          // Prefer explicit 'response' field from your API
          if (typeof obj.response === 'string' && obj.response) return obj.response;
          // Spring AI ChatResponse nested path
          const maybe = obj?.result?.output?.text;
          if (typeof maybe === 'string' && maybe) return maybe;
          // Some providers put text directly
          if (typeof obj.text === 'string' && obj.text) return obj.text;
          return '';
        }

        function consumeJsonObjects(bufferStr) {
          const objects = [];
          let i = 0;
          const n = bufferStr.length;
          while (i < n) {
            // find next '{'
            let start = bufferStr.indexOf('{', i);
            if (start === -1) break;
            let depth = 0;
            let inString = false;
            let escape = false;
            for (let j = start; j < n; j++) {
              const ch = bufferStr[j];
              if (inString) {
                if (escape) { escape = false; continue; }
                if (ch === '\\') { escape = true; continue; }
                if (ch === '"') { inString = false; continue; }
              } else {
                if (ch === '"') { inString = true; continue; }
                if (ch === '{') depth++;
                else if (ch === '}') {
                  depth--;
                  if (depth === 0) {
                    const segment = bufferStr.slice(start, j + 1);
                    try {
                      const obj = JSON.parse(segment);
                      objects.push(obj);
                      i = j + 1; // continue searching after this object
                      break;
                    } catch {
                      // not a complete/valid JSON; move i forward to find next '{'
                      i = start + 1;
                      break;
                    }
                  }
                }
              }
              if (j === n - 1) {
                // reached end without closing
                i = start; // keep from start for next chunk
              }
            }
            // If depth never reached 0 and loop ended, we break to await more data
            if (depth > 0) break;
          }
          // leftover is from last processed index i to end
          const leftover = bufferStr.slice(i);
          return { objects, leftover };
        }

        function autoGrowTextArea() {
          elInput.style.height = 'auto';
          const next = Math.min(elInput.scrollHeight, maxInputPx);
          elInput.style.height = next + 'px';
          // 输入高度变化应同步到父容器，标记来源为 input
          requestResize('input');
        }

        function addMessage(role, text) {
          const wrap = document.createElement('div');
          wrap.className = 'msg ' + role;
          if (mode === 'full') {
            const avatar = document.createElement('div');
            avatar.className = 'avatar';
            if (role !== 'assistant') avatar.style.display = 'none';
            wrap.appendChild(avatar);
          }
          const bubble = document.createElement('div');
          bubble.className = 'bubble';
          bubble.textContent = text || '';
          wrap.appendChild(bubble);
          elMessages.appendChild(wrap);
          elMessages.scrollTop = elMessages.scrollHeight;
          requestResize();
          return bubble;
        }

        function addMessageAtTop(role, text) {
          const wrap = document.createElement('div');
          wrap.className = 'msg ' + role;
          if (mode === 'full') {
            const avatar = document.createElement('div');
            avatar.className = 'avatar';
            if (role !== 'assistant') avatar.style.display = 'none';
            wrap.appendChild(avatar);
          }
          const bubble = document.createElement('div');
          bubble.className = 'bubble';
          bubble.textContent = text || '';
          wrap.appendChild(bubble);
          const prevHeight = elMessages.scrollHeight;
          elMessages.insertBefore(wrap, elMessages.firstChild);
          const newHeight = elMessages.scrollHeight;
          // keep viewport position
          elMessages.scrollTop += (newHeight - prevHeight);
          requestResize();
          return bubble;
        }

        function setDisabled(next) {
          disabled = next;
          elInput.disabled = next;
          elSend.disabled = next || !elInput.value.trim();
          if (next) {
            elSend.innerHTML = '<span class="spinner"></span>';
          } else {
            elSend.innerHTML = '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M2 21L23 12L2 3V10L17 12L2 14V21Z" fill="currentColor"/></svg>';
          }
        }

        function requestResize(from){
          // Include root height
          const height = document.documentElement.scrollHeight;
          parent.postMessage({ type: 'chat:resize', height, from: from || 'content' }, '*');
        }

        // Observe content changes for resize
        const mo = new MutationObserver((mutations) => {
          // 仅在消息内容变更（新增/文本变化）时调整高度
          const need = mutations.some(m => m.type === 'childList' || m.type === 'characterData');
          if (need) requestResize();
        });
        mo.observe(elMessages, { childList: true, subtree: true, characterData: true });

        // Input handlers
        elInput.addEventListener('input', () => {
          autoGrowTextArea();
          if (!disabled) elSend.disabled = !elInput.value.trim();
        });
        elInput.addEventListener('keydown', (e) => {
          if (e.key === 'Enter' && !e.shiftKey && !disabled) {
            e.preventDefault();
            sendMessage();
          }
        });
        elSend.addEventListener('click', () => { if (!disabled) sendMessage(); });

        // MCP menu toggle (hidden when external control is enabled)
        function toggleMenu(open) {
          elMcpMenu.classList.toggle('open', open);
        }
        if (!externalMcp) {
          elMcp.addEventListener('click', (e) => {
            e.stopPropagation();
            toggleMenu(!elMcpMenu.classList.contains('open'));
          });
          document.addEventListener('click', (e) => {
            if (!elMcpMenu.contains(e.target) && e.target !== elMcp) {
              toggleMenu(false);
            }
          });
          // MCP switch
          elMcpSwitch.addEventListener('change', () => {
            mcpEnabled = elMcpSwitch.checked;
            elMcp.classList.toggle('enabled', mcpEnabled);
            // 不触发 resize，避免无意义高度变化
          });
        } else {
          // Hide internal MCP UI if controlled externally
          if (elMcp) elMcp.style.display = 'none';
          if (elMcpMenu) elMcpMenu.style.display = 'none';
        }
        // Open settings => notify parent
        document.getElementById('openSettings').addEventListener('click', () => {
          parent.postMessage({ type: 'chat:openSettings' }, '*');
          toggleMenu(false);
        });

        async function sendMessage(){
          const text = elInput.value.trim();
          if (!text) return;
          // Compact: clear and only show latest AI response
          if (mode === 'compact') {
            elMessages.innerHTML = '';
          } else {
            // Show user message in full mode
            addMessage('user', text);
          }
          elInput.value = '';
          autoGrowTextArea(); // reset to minimal
          setDisabled(true);

          // Prepare assistant bubble for streaming
          const assistantBubble = addMessage('assistant', '');
          // Sentence queue and current index (for compact mode)
          let sentences = ['']; // last element is always the building remainder
          let currentIndex = -1;  // -1 means not showing any sentence yet
          let typewriterTimer = null;
          const TYPE_SPEED = 20; // ms per char

          function splitSentences(bufferStr) {
            const completed = [];
            let current = '';
            for (let i = 0; i < bufferStr.length; i++) {
              const ch = bufferStr[i];
              // Treat '...' as ellipsis (not a sentence boundary)
              if (ch === '.' && bufferStr.slice(i, i + 3) === '...') {
                current += '...';
                i += 2; // skip the next two dots
                continue;
              }
              current += ch;
              const isBoundary = (
                ch === '。' || ch === '！' || ch === '？' || ch === '!' || ch === '?' || ch === '.'
              );
              if (isBoundary) {
                completed.push(current);
                current = '';
              }
            }
            return { completed, remainder: current };
          }

          function renderCurrentSentenceWithTypewriter() {
            if (mode !== 'compact') return;
            if (typewriterTimer) { clearInterval(typewriterTimer); typewriterTimer = null; }
            if (currentIndex < 0) return;
            const text = (sentences[currentIndex] || '').trim();
            let pos = 0;
            assistantBubble.textContent = '';
            typewriterTimer = setInterval(() => {
              if (pos >= text.length) {
                clearInterval(typewriterTimer);
                typewriterTimer = null;
                return;
              }
              assistantBubble.textContent += text[pos++];
              elMessages.scrollTop = elMessages.scrollHeight;
              requestResize();
            }, TYPE_SPEED);
          }

          function handleAssistantDelta(deltaText) {
            if (!deltaText) return;
            if (mode === 'compact') {
              // Append to the building sentence (last element), keep remainder always last
              let lastIdx = sentences.length - 1;
              const merged = (sentences[lastIdx] || '') + deltaText;
              const seg = splitSentences(merged);
              // For each completed sentence, move remainder slot forward and append empty slot
              for (const s of seg.completed) {
                sentences[lastIdx] = s; // finalize current sentence in the last slot
                sentences.push('');     // create new remainder slot
                lastIdx = sentences.length - 1;
              }
              // Update current remainder in the last slot
              sentences[sentences.length - 1] = seg.remainder;

              // Auto-show first completed sentence once available
              const maxCompletedIndex = sentences.length - 2; // exclude remainder
              if (currentIndex === -1 && maxCompletedIndex >= 0) {
                currentIndex = 0;
                renderCurrentSentenceWithTypewriter();
              }
            } else {
              // full mode: append as usual
              assistantBubble.textContent += deltaText;
              elMessages.scrollTop = elMessages.scrollHeight;
              requestResize();
            }
          }

          // History sharing between compact and full modes
          function snapshotHistory() {
            if (mode !== 'compact') return [];
            const maxCompleted = sentences.length - 2; // exclude remainder
            const result = [];
            for (let i = 0; i <= maxCompleted; i++) {
              result.push(sentences[i].trim());
            }
            return result.filter(Boolean);
          }

          window.addEventListener('message', (e) => {
            const data = e.data || {};
            if (data.type === 'chat:getHistory' && mode === 'compact') {
              parent.postMessage({ type: 'chat:history', messages: snapshotHistory() }, '*');
            }
            if (data.type === 'chat:history' && mode === 'full') {
              // Render history into full chat
              elMessages.innerHTML = '';
              for (const msg of (data.messages || [])) {
                const b = addMessage('assistant', '');
                b.textContent = msg;
              }
              requestResize();
            }
          });

          // Navigation: click to next, wheel up/down to prev/next (compact only)
          function getMaxCompletedIndex() {
            return sentences.length - 2; // exclude remainder
          }
          function showIndex(nextIdx) {
            if (mode !== 'compact') return;
            const maxIdx = getMaxCompletedIndex();
            if (nextIdx < 0 || nextIdx > maxIdx) return;
            currentIndex = nextIdx;
            renderCurrentSentenceWithTypewriter();
          }
          function showNext() { showIndex(currentIndex + 1); }
          function showPrev() { showIndex(currentIndex - 1); }
          function fastForwardCurrent() {
            if (mode !== 'compact') return;
            if (currentIndex < 0) return;
            if (typewriterTimer) { clearInterval(typewriterTimer); typewriterTimer = null; }
            assistantBubble.textContent = (sentences[currentIndex] || '').trim();
            elMessages.scrollTop = elMessages.scrollHeight;
            requestResize();
          }

          elMessages.addEventListener('click', () => {
            if (mode !== 'compact') return;
            const maxIdx = getMaxCompletedIndex();
            if (currentIndex < 0 && maxIdx >= 0) {
              showIndex(0);
            } else if (typewriterTimer) {
              fastForwardCurrent();
            } else {
              showNext();
            }
          });
          elMessages.addEventListener('wheel', (e) => {
            if (mode !== 'compact') return;
            e.preventDefault();
            if (typewriterTimer) {
              fastForwardCurrent();
              return;
            }
            if (e.deltaY < 0) showPrev();
            else if (e.deltaY > 0) showNext();
          }, { passive: false });

          try {
            const endpoint = mcpEnabled ? endpointMcp : endpointNormal;
            const url = endpoint + '?message=' + encodeURIComponent(text);
            const res = await fetch(url, {
              method: mcpEnabled ? 'POST' : 'GET',
              headers: {
                'Accept': 'text/event-stream, application/stream+json, application/x-ndjson, */*'
              },
              cache: 'no-cache'
            });
            if (!res.ok || !res.body) throw new Error('请求失败');

            const reader = res.body.getReader();
            const decoder = new TextDecoder('utf-8');
            let buffer = '';
            const ct = (res.headers.get('content-type') || '').toLowerCase();
            const isSse = ct.includes('text/event-stream');
            const isNdjson = ct.includes('application/stream+json') || ct.includes('application/x-ndjson');

            while (true) {
              const { done, value } = await reader.read();
              if (done) break;
              const chunk = decoder.decode(value, { stream: true });
              buffer += chunk;

              if (isSse) {
                // SSE blocks separated by blank line
                const parts = buffer.split(/\n\n|\r\n\r\n/);
                buffer = parts.pop() || '';
                for (const block of parts) {
                  const lines = block.split(/\r?\n/);
                  for (const line of lines) {
                    if (!line) continue;
                    if (line.startsWith('data:')) {
                      const payload = line.slice(5).trim();
                      if (payload.startsWith('{')) {
                        try {
                          const obj = JSON.parse(payload);
                          const text = extractTextFromObj(obj);
                          if (text) handleAssistantDelta(text);
                        } catch {
                          // ignore raw json text
                        }
                      } else {
                        // ignore non-JSON SSE payload to avoid dumping raw lines
                      }
                    }
                  }
                  elMessages.scrollTop = elMessages.scrollHeight;
                  requestResize();
                }
              } else if (isNdjson) {
                // NDJSON or application/stream+json: one JSON per line
                const lines = buffer.split(/\r?\n/);
                buffer = lines.pop() || '';
                for (const line of lines) {
                  if (!line.trim()) continue;
                  try {
                    const obj = JSON.parse(line);
                    const text = extractTextFromObj(obj);
                    if (text) handleAssistantDelta(text);
                  } catch {
                    // ignore partial
                  }
                }
              } else {
                // Fallback: parse concatenated JSON objects and only append extracted text
                const consumed = consumeJsonObjects(buffer);
                buffer = consumed.leftover;
                for (const obj of consumed.objects) {
                  const text = extractTextFromObj(obj);
                  if (text) handleAssistantDelta(text);
                }
              }
            }
          } catch (err) {
            assistantBubble.textContent += '\n[错误] ' + (err && err.message ? err.message : '请求异常');
          } finally {
            setDisabled(false);
          }
        }

        // ---------- Full mode: history fetch & infinite up-scroll ----------
        function parseHistoryText(textContent) {
          if (!textContent) return '';
          try {
            const maybeObj = JSON.parse(textContent);
            const t = extractTextFromObj(maybeObj);
            return t || textContent;
          } catch {
            return textContent;
          }
        }

        async function loadHistoryFromApi() {
          try {
            const res = await fetch(endpointHistory, { method: 'GET', headers: { 'Accept': 'application/json' }, cache: 'no-cache' });
            if (!res.ok) throw new Error('history request failed');
            const arr = await res.json();
            historyCache = Array.isArray(arr) ? arr.map((it) => ({
              role: (it.messageType || '').toLowerCase() === 'user' ? 'user' : 'assistant',
              text: parseHistoryText(it.textContent)
            })) : [];
            // initial window: show last page
            const len = historyCache.length;
            historyLoadedEnd = len;
            historyLoadedStart = Math.max(0, len - historyPageSize);
            // render initial slice in order
            const slice = historyCache.slice(historyLoadedStart, historyLoadedEnd);
            for (const item of slice) {
              const b = addMessage(item.role, '');
              b.textContent = item.text || '';
            }
          } catch (e) {
            // ignore
          }
        }

        function canLoadMoreHistory() {
          return historyLoadedStart > 0;
        }

        function loadMoreHistoryUp() {
          if (!canLoadMoreHistory()) return;
          const newStart = Math.max(0, historyLoadedStart - historyPageSize);
          const batch = historyCache.slice(newStart, historyLoadedStart);
          // insert at top in order from older to newer
          for (let i = 0; i < batch.length; i++) {
            const item = batch[i];
            addMessageAtTop(item.role, item.text || '');
          }
          historyLoadedStart = newStart;
        }

        // Parent -> Frame messages
        window.addEventListener('message', (e) => {
          const data = e.data;
          if (!data || typeof data !== 'object') return;
          if (data.type === 'chat:mcp') {
            mcpEnabled = !!data.enabled;
            elMcp.classList.toggle('enabled', mcpEnabled);
            elMcpSwitch.checked = mcpEnabled;
            requestResize();
          }
        });

        // Note: clicking the hamburger only toggles menu, does not change height

        // If mode is full, fetch history and setup infinite scroll
        if (mode === 'full') {
          loadHistoryFromApi();
          let ticking = false;
          elMessages.addEventListener('scroll', () => {
            if (ticking) return;
            ticking = true;
            requestAnimationFrame(() => {
              if (elMessages.scrollTop <= 0) {
                loadMoreHistoryUp();
              }
              ticking = false;
            });
          });
        }

        // Init
        autoGrowTextArea();
        requestResize();
      })();
    </script>
  </body>
  </html>


